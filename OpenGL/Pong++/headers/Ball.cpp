#include "Models.h"

//Moves the ball adding the Xinc & Yinc to the X & Y positions respectively
GLvoid Ball::moveBall(GLfloat deltaTime) {
	GLfloat ballX = getXValue();
	GLfloat ballY = getYValue();

	ballX += getBallXinc() * deltaTime;
	ballY += getBallYinc() * deltaTime;

	setXValue(ballX);
	setYValue(ballY);
}//end moveBall

//Called when ball hits a paddle. Negates Xinc and will determine whether to negate Yinc based on the value generated by negateOrNot()
Glvoid Ball::changeDirection() {
	ballXinc *= -1;
	ballYinc = nagateOrNot(ballYinc);  //change the Y direction if a 1 (one) is generated
}//end changeDirection

//Increses(or decrease, depending on which direction the ball is travelling) to Xinc and Yinc by a small number each time the ball collides with a paddle
GLvoid Ball::increaseSpeed() {
	//------ X speed --------//
	if (ballXinc > 0)
		ballXinc += 0.003;
	if (ballXinc < 0)
		ballXinc -= 0.003;

	//------ Y speed --------//
	if (ballYinc > 0)
		ballYinc += 0.0003;
	if (ballYinc < 0)
		ballYinc -= 0.0003;
} //end increaseSpeed

//Give the ball extra speed after it collides with the extra speed powerup
GLvoid Ball::extraSpeed() {
	ballXinc += 1;
	ballYinc += 0.8;
}//end extraSpeed

//Set the speed to the values before the powerup after it has worn off
GLvoid Ball::resetSpeed() {
	ballXinc -= 1;
	ballYinc -= 0.8;
}//end resetSpeed


//If the ball has been brought forward to the right position then return true and stop bring it forward.
//Until then add the Zinc to the Z pos to allow the ball to have some sort of an entrance (may not work with the background image on the board)
GLboolean Ball::bringForward() {
	if (ballZ >= 0.0) {
		ballZ = 0.0;
		return true;
	}

	ballZ += ballZinc;
	return fasle;
}//end bring forawrd


//If the ball has reached the edge of the board the respond appropriately.
GLvoid Ball::boundaryCheck() {
	if (ballX > ballXend || ballX < (ballXend * -1))
		ballXinc *= -1;

	if (ballY > ballYend || ballY < (ballYend * -1))
		ballYinc *= -1;
}//end boundary check